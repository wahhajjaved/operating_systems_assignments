<html>
<head>
<title>CMPT 332 - Lab 1 - Fall 2024</title>
</head>
<body>
<img src="splashBanner.gif" align="middle">
<h1>
  CMPT 332 - Lab 1 - Fall 2024 <br>
  University of Saskatchewan <br>
  Lab 1: Make and virtualization
</h1>

<p><b>Instructor:</b> Dwight Makaroff</p>
<p><b>Out:</b> September 9th, 2024</p>
<p><b>Due:</b> 9:00 p.m. Thursday, September 12th, 2024</p>
<b>TOTAL MARKS: 5</b>

<h2 id="preface">Preface</h2>
<p>You will to use a Linux lab machine for this lab. For remote access,
Use the 'ssh' command to get to tuxworld.usask.ca. Work on the first 3
  parts of this lab in parallel. Let the computer do the work for
  you, so you don't have to sit and wait for the virtual machine to
  install.</p>
<h2 id="description">Activities/Description</h2>

<h3 id="make">1. Multi-architecture Make</h3>
<p>Make is an incredibly powerful tool for building <em>targets</em>
  that have a dependency tree. It will only execute targets that have
  a dependency that has changed. This section of the lab will guide
  you through building a basic Makefile that compiles executables
  for an Intel 64-bit Linux system, a virtual machine with the ARM
  architecture (cmpt332-arm), and a virtual machine with a PowerPC
  architecture (cmpt332-ppc). Whenever you feel like you've made a 
  resonable step forward in progress, commit to git (at least every
  15 minutes). This is a review of Lab 0, with some added features.</p> 
<p>There are 3 source files: <code>sample-linux.c</code>, <code>linux-lib.c</code>,
  and <code>lab1.h</code>. <strong>Do not edit these files</strong>.</p> 
<p>First start out by defining a couple of variables.</p>
<pre><code>CC = gcc
CFLAGS = -g
CPPFLAGS = -std=gnu90 -Wall -pedantic
</code></pre>
<p>You should use the <code>CPPFLAGS</code> variable whenever the C 
pre-processor runs, and <code>CFLAGS</code> whenever the C compiler
runs.
  <code>CC</code> is used to specify which compiler you want to
  use. When searching 
for include files and/or libraries, you must explicitly specify where the
files you need are located. The -I and -L directives to the compiler/linker,
  respectively will be necessary.</p>
<p>You will also need variables/targets for the executables on the
  various architectures that are required.
<p>The makefile must do the following:</p>
<ul>
<li>compile <code>sample-linux.c</code>  and <code>linux-lib.c</code> for
	Linux into the appropriate .o files. <b>NEVER</b> compile
an executable directly from source code. Always generate the intermediate
.o file.</li>
<li>archive <code>linux-lib.o</code> into a library .a  file  (use
  the <code>ar</code> command) </li>
<li>link the <code>sample_linux.o</code>, pthreads library  and the
  linux-lib library to
  a <code>sample-linux</code> executable (using the <code>-L</code>
  and <code>-l</code> directives).</li>
<li>have a target for each architecture: x86_64, arm, and ppc.</li>
</ul>



<p> When you're on a Linux/Intelx86 system, you typically only want to compile
    and link the Linux/Intelx86 files. NORMALLY, you can detect this with
    <code>uname</code>. Correspondingly, when on a Linux/ARM, Windows, or Linux/PPC
    architecture, you will need to link with the correct
    libraries. Linking against UBC PThreads will also need the linker to
    look inside the operating system-specific and machine architecture-specific
    subdirectory of <code>/student/cmpt332/pthreads/lib</code>. 
    The  names of these subdirectories were generated by <code>uname
    -s</code> and <code>uname -m</code> combined.
    The name of the library is <code>libpthreads.a</code>. To know which
    system you are running, there is likely an environment variable called
    $OS that is defined when you log in. Do NOT use this variable from
    your environment, because that is not defined for the instructor's
    environment. If you use $OS, explicitly define it inside the makefile.</p>

<h3 id="org"><code>Directory Organization</code></h3>
<p> The files your Makefile produces could be organized into separate folders
    based on their architecture. As easy way to do this is have everything
    starting in a <code>build</code> directory then have
    <code>build/obj/ARCH</code>, <code>build/lib/ARCH</code>, <code>build/bin/ARCH</code>.
    This way when you clean with your Makefile you can just remove the
    build directory. </p>

  
<p>Make has documentation online and the manual can be
  found <a href="https://www.gnu.org/software/make/manual/make.html">here</a>
  or the reference document in the course notes under "Software
  Resources and Documentation".</p>
<p> For this course, we want to keep
  makefiles simple and straightforward. There will be no
  automatically generated makefiles (i.e. <b>cmake</b> is specifically
  not permitted) and the use of sophisticated makefile magic is
  discouraged unless you really know what you are doing. Check with a
  TA if you intend to get fancy with your makefiles. In this level of
  software development, we want to have explicit control of exactly what gets
  compiled and linked. If you have any questions about this, please
  ask. </p>


<h3 id="cc"><code>Cross-Compiling</code></h3>
<p> Cross compiling allows you to create executable files for an architecture
    that isn't the one you're currently using. 
  We are focussing on compiling for two architectures:
  <ol>
    <li>
    Raspberry Pi (cmpt332-arm): ARM architecture machine (actually a 
    Virtual Machine made to look like a Raspberry Pi). Nearly all Cell
    phones use the ARM architecture, and many laptops, tablets and
    other embedded systems are based on the ARM architecture.</li>
    <li> PowerPC (cmpt332-ppc): "One of the original architecures for Apple
    hardware. It has since become a niche in personal computers, but
    remains popular for embedded and high-performance processors. Its
    use in the 7th generation of video game consoles and embedded
    applications provide an array of uses, including satellites, and
    the Curiosity and Perseverance rovers on Mars. In addition,
    PowerPC CPUs are still used in AmigaOne and third party AmigaOS 4
    personal computers."  (Wikipedia).
    </li>
    
  </ol>

In this case, the suggestion to use <code>uname</code> will not work.

<p>
  To do this, use
    separate command/rules to do the following (for each architecture): </p>
    <ul>
        <li>Create a new rule specifically for cross compiling for the RPi </li>
        <li> Use a new
        variable <code>CROSS_COMPILE=arm-linux-gnueabihf-</code>. This
        variable gives the prefix for the build tools for the other
        architecture. Here we can see that it is Linux for the ARM
        architecture. 
	Specifically, you can then access gcc, cpp, etc.</li> 
        <li> Compile <code>sample-raspi.o</code> for ARM architecture
        (or use the structure above).
        from <code>sample-linux.c</code></li> 
        <li> Compile <code>raspi-lib.o</code> from <code>linux-lib.c</code></li> 
	<li> Convert <code>raspi-lib.o</code> into a library <code>.a</code>
	file </li>
	<li> Generate (via linking) a <code>sample-linux-arm</code>
	executable from <code>sample-raspi.o</code> and your local
	library and the UBC Pthreads library. Use whatever make
	targets you wish so that the appropriate binaries are built from
	your make command. The marking script will only
	run <code>make</code>.</li> 
	<li> Ensure that the binary is in the main level of your
	  directory.
	</li>
	<li> Repeat the same steps for the PowerPC architecture, with
	the appropriate prefix for the compiler and the
	text <code>ppc</code> for the object and executables.</li>
    </ul>

<p>    Now verify that the program runs on the ARM architecture by doing
    an 'ssh cmpt332-arm' and 'ssh cmpt332-ppc', respectively (Note:
    these machines are not accessible from
    outside campus; you need to do this in tuxworld or from a lab Linux
    box) and then executing the program there. Do not 
    compile on the virtual machine. You <b>could</b> compile there, but
    the point is to be able to cross-compile. This is useful when the
    target machine is resource-challenged as these VMs are.n
<p> </p>

<h3 id="bash-scripting">2. Bash Scripting</h3>
<p>Write a bash script called <code>run-lab1.bash</code> that
 that verifies the correct number of command-line arguments, and runs
 the appropriate binary, passing any command line
 arguments through to  the executable. At first glance, this may seem
 unnecessary, but it  will be necessary/useful in future
 labs/assignments where you are going to be compiling and running
 programs on different hardware architectures.</p>
<h3 id="virtual-machine">3. Virtual Machine</h3>

<p>In this lab you will be installing an Ubuntu Server virtual
  machine, building and installing a bleeding edge version of python.
</p>

<ul>
<li>First ssh into trux, and launch virtualbox</li>
<ul>
<li><p><code>$ ssh -Y trux</code></p></li>
<li><p><code>$ virtualbox &amp;</code></p></li>
</ul>
<li>

<p>Under 'Preferences' change the 'Default Machine Folder'
  from <code>/student/$NSID</code> to <code>/u2/cmpt332/$NSID</code></p>
</li>
<li>
<p>Create a new virtual machine named whatever you think is
  appropriate. Make sure to select Linux as the type, and Ubuntu (64
  bit) as the version.</p>
</li>
<li>
<p>Give the virtual machine 4GB of memory, and create a new virtual
  hard disk.</p>
<ul>
<li>Select VDI for the Hard disk file type, and ensure that it is a fixed size 
of 50 GB and then hit the create button.</li>
</ul>
</li>
<li>
<p>Click on settings, System, and give yourself 4 Processor(s) to
  finish your vm initialization.</p>
</li>
<li>
<p>Start the machine in headless mode.</p>
<ul>
<li>You'll notice that no window appears, this is normal!</li>
</ul>
</li>
<li>
<p>Select the vm you created and click the green 'Show' arrow.</p>
</li>
</ul>
<p>Virtualbox should now be asking for a start-up disk. Select the Ubuntu Server image from /u2/cmpt332/images. 
The display will likely look very strange at this point. From the View dropdown,
once the machine is trying to install from the image, select 'Scaled Display'
After hitting ok, you may need to reset the virtual machine.</p>
<p>Follow the on-screen instructions. You don't need to install
  openssh server or any 'server snaps'. Make sure you wait for updates
  to finish installing, then select 'Reboot', and
  hit <code>Enter</code> if prompted. You have now installed your
  virtual machine!</p> 
<p><strong>Note</strong>, if you don't allow updates to install before
  you reboot, you are running an untested configuration and the TAs
  will not be able to assist.</p> 
<p><strong>IMPORTANT:</strong> If you ever need to take a break from
  the lab, click on 'Machine' and select 'Detach GUI'. This will allow
  your vm to keep working while you are away. Do not close the virtual
  machine by clicking the window's close button, as this will shut
  down your vm.</p>

<p>Log in to your virtual machine and confirm that it is running by
  capturing the text from the execution of <code>uname -a</code>. Place
  this in the file <code>vm-verification.txt</code>.
</p>
<h3>4. Read the Field Manual! (Building Bleeding Edge Python from source)</h3>
<p>Prior to starting, run <code>$ script python.txt</code>. This will
  create a text file of your terminal output for you to hand in.</p> 
<p>First you want to clone the latest version of python's git repository.<br>
<code>$ git clone https://github.com/python/cpython.git</code></p>
<p>Now follow the build instructions from the Readme located  <a href="https://github.com/python/cpython">here</a>.</p>
<p>There are two ways you can do this: The painful way of repeatedly
  running ./configure and installing dependencies as you discover they
  are missing, or reading the entire build instructions section of the
  readme before starting. TAs will not assist you if you are using the
  painful method.</p> 
<p>Once compilation is complete, make sure to run the tests, install
  your new version of Python, and finish off with a <code>$ python3
  version</code> to show you have completed the exercise. Remember to
  stop the script with <code>ctrl+d</code> once you have finished this
  part of the lab.</p>   
  
<h2 id="deliverables">Deliverables</h2>
<p>A single tar file containing
  your <code>Makefile</code>, <code>run-lab1.bash</code>, a text file
  containing the output of your <code>git log</code>
  called <code>git-log.txt</code>, a text file containing the login
  and verification of your virtual machine
  installation <code>vm-verification.txt</code>, and the output of your python
  compilation <code>python.txt</code>.</p>

<h2 id="submission">Submission</h2>
<p>
Create a .tar file (using <code>tar -cvf</code>, double-check
with <code>tar -tvf</code>) with the 5 files (no
directories) in the next section and submit it to Lab 1.
</p>
<p>
  General Guidelines:

  <ul>
    <li>Unless otherwise specified, your name, NSID and Student
    number <b>must be at the beginning</b> of <b>each individual
    file</b> that you hand in. That is each source file, each
    documentation file, each Makefile, each testing output, and each
    log file.</li> 
    <li>Submit files only. Never submit anything that is explicitly
      inside a directory, unless otherwise indicated.</li>
    <li>Never submit binaries or executables.</li>
    <li>Make sure that the lines in all text/code files are 80 characters 
      wide at most. This is to facilitate the marker's
      convenience. If you have to indent such that this is necessary,
      refactor your code. Something is wrong with your design.</li>
    <li>Double check your .tar file before submission. Tar files may get
      accidentally garbled. Untar your file and verify its contents before
      submission.</li>
    <li>Do not use any compression method on your tar file. The file should be
      uncompressed (ending in ".tar" only). Canvas will enforce
      this. Under no circumstances should you make a file of another
      type (e.g. zip) and rename it as a tar file. This cannot be
      accepted and will not be tolerated.</li>
  </ul>
</p>

<h2 id="grading">Grading</h2>
<ul>
<li><code>Makefile</code>: 1 mark</li>
<li><code>run.bash</code>: 1 mark</li>
<li><code>git-log.txt</code>: 1 mark</li>
<li><code>vm-verification.txt</code>: 1 mark</li>
<li><code>python.txt</code>: 1 mark</li>

</ul>
</body>
