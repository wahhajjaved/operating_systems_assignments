diff --git a/assignments/xv6/.gdbinit.tmpl-riscv b/assignments/xv6/.gdbinit.tmpl-riscv
new file mode 100644
index 0000000..faff3cc
--- /dev/null
+++ b/assignments/xv6/.gdbinit.tmpl-riscv
@@ -0,0 +1,6 @@
+set confirm off
+set architecture riscv:rv64
+target remote 127.0.0.1:1234
+symbol-file kernel/kernel
+set disassemble-next-line auto
+set riscv use-compressed-breakpoints yes
\ No newline at end of file
diff --git a/assignments/xv6/Makefile b/assignments/xv6/Makefile
index 255d57d..c3dd09f 100644
--- a/assignments/xv6/Makefile
+++ b/assignments/xv6/Makefile
@@ -139,6 +139,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_pingpong\
+	$U/_primes\
+	$U/_trace\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/assignments/xv6/kernel/proc.c b/assignments/xv6/kernel/proc.c
index a935855..e9f6e65 100644
--- a/assignments/xv6/kernel/proc.c
+++ b/assignments/xv6/kernel/proc.c
@@ -33,7 +33,7 @@ void
 proc_mapstacks(pagetable_t kpgtbl)
 {
   struct proc *p;
-  
+
   for(p = proc; p < &proc[NPROC]; p++) {
     char *pa = kalloc();
     if(pa == 0)
@@ -48,7 +48,7 @@ void
 procinit(void)
 {
   struct proc *p;
-  
+
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
   for(p = proc; p < &proc[NPROC]; p++) {
@@ -93,7 +93,7 @@ int
 allocpid()
 {
   int pid;
-  
+
   acquire(&pid_lock);
   pid = nextpid;
   nextpid = nextpid + 1;
@@ -236,7 +236,7 @@ userinit(void)
 
   p = allocproc();
   initproc = p;
-  
+
   /* allocate one user page and copy initcode's instructions */
   /* and data into it. */
   uvmfirst(p->pagetable, initcode, sizeof(initcode));
@@ -319,6 +319,7 @@ fork(void)
   release(&wait_lock);
 
   acquire(&np->lock);
+  np->traceMask =p->traceMask;
   np->state = RUNNABLE;
   release(&np->lock);
 
@@ -372,7 +373,7 @@ exit(int status)
 
   /* Parent might be sleeping in wait(). */
   wakeup(p->parent);
-  
+
   acquire(&p->lock);
 
   p->xstate = status;
@@ -428,7 +429,7 @@ wait(uint64 addr)
       release(&wait_lock);
       return -1;
     }
-    
+
     /* Wait for a child to exit. */
     sleep(p, &wait_lock);  /*DOC: wait-sleep */
   }
@@ -548,7 +549,7 @@ void
 sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
+
   /* Must acquire p->lock in order to */
   /* change p->state and then call sched. */
   /* Once we hold p->lock, we can be */
@@ -627,7 +628,7 @@ int
 killed(struct proc *p)
 {
   int k;
-  
+
   acquire(&p->lock);
   k = p->killed;
   release(&p->lock);
diff --git a/assignments/xv6/kernel/proc.h b/assignments/xv6/kernel/proc.h
index 1d7d309..50b7cf0 100644
--- a/assignments/xv6/kernel/proc.h
+++ b/assignments/xv6/kernel/proc.h
@@ -92,6 +92,8 @@ struct proc {
   int xstate;                  /* Exit status to be returned to parent's wait */
   int pid;                     /* Process ID */
 
+  int traceMask;             /* added for part E Mask of syscall for trace*/
+
   /* wait_lock must be held when using this: */
   struct proc *parent;         /* Parent process */
 
diff --git a/assignments/xv6/kernel/syscall.c b/assignments/xv6/kernel/syscall.c
index 5ae08cc..06e6ba1 100644
--- a/assignments/xv6/kernel/syscall.c
+++ b/assignments/xv6/kernel/syscall.c
@@ -101,6 +101,7 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_trace(void);
 
 /* An array mapping syscall numbers from syscall.h */
 /* to the function that handles the system call. */
@@ -126,8 +127,25 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_trace]   sys_trace
 };
 
+/* array of sys call names */
+char syscallnames[22][10]= {
+    "read",
+    "trace",
+    "exec",
+    "open",
+    "close",
+    "fork",
+    "kill",
+    "mkdir",
+    "pipe",
+    "wait"
+
+};
+
+
 void
 syscall(void)
 {
@@ -139,6 +157,11 @@ syscall(void)
     /* Use num to lookup the system call function for num, call it, */
     /* and store its return value in p->trapframe->a0 */
     p->trapframe->a0 = syscalls[num]();
+    /* for part e print sys call names */
+    if ((p->traceMask) & (1<< num)) {
+        printf("%d: syscall %s -> %ld\n", p->pid, syscallnames[num-1],p->trapframe->a0);
+    }
+
   } else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
diff --git a/assignments/xv6/kernel/syscall.h b/assignments/xv6/kernel/syscall.h
index 95eab25..1195113 100644
--- a/assignments/xv6/kernel/syscall.h
+++ b/assignments/xv6/kernel/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_trace  22
diff --git a/assignments/xv6/kernel/sysproc.c b/assignments/xv6/kernel/sysproc.c
index 2ab1bc1..7cd4860 100644
--- a/assignments/xv6/kernel/sysproc.c
+++ b/assignments/xv6/kernel/sysproc.c
@@ -91,3 +91,15 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_trace(void)
+{
+    int mask; /* to hols trace mask*/
+    struct proc *p =myproc();
+    argint(0, &mask); /* aquire the mask*/
+    acquire (&p->lock);
+    p->traceMask = mask; /*set the trace mask*/
+    release (&p->lock);
+    return 0;
+}
diff --git a/assignments/xv6/user/pingpong.c b/assignments/xv6/user/pingpong.c
new file mode 100644
index 0000000..d756aa4
--- /dev/null
+++ b/assignments/xv6/user/pingpong.c
@@ -0,0 +1,114 @@
+/*
+* @author Wahhaj Javed, muj975, 11135711
+* @author Nakhba Mubashir, epl482, 11317060
+* @date 2024-09-22
+*/
+
+#include "kernel/types.h"
+#include "user/user.h"
+
+int pToC[2];
+int cToP[2];
+char b = 'p';
+
+int child() {
+	char buffer;
+	int bytesRead, bytesWritten;
+	bytesRead = read(pToC[0], &buffer, 1);
+	if (bytesRead == -1) {
+		printf("Error when reading byte from parent\n");
+		return 1;
+	}
+	else if (bytesRead != 1) {
+		printf("Error in child: Expected to read 1 byte but instead read %d"
+			"\n",
+			bytesRead
+		);
+		return 1;
+	}
+	
+	if(buffer == b) {
+		printf("%d: received ping\n", getpid());
+	}
+	else {
+		printf("Error in child. Expecting %d but got %d\n", b, buffer);
+		return 1;
+	}
+	
+	bytesWritten = write(cToP[1], &b, 1);
+	if (bytesWritten == -1) {
+		printf("Error when sending byte to child\n");
+	}
+	else if (bytesWritten != 1) {
+		printf("Error in parent: Expected to write 1 byte but instead wrote %d"
+			"\n",
+			bytesWritten
+		);
+	}
+	
+	return 0;
+}
+
+int parent() {
+	char buffer;
+	int bytesRead, bytesWritten;
+	bytesWritten = write(pToC[1], &b, 1);
+	if (bytesWritten == -1) {
+		printf("Error when sending byte to child\n");
+	}
+	else if (bytesWritten != 1) {
+		printf("Error in parent: Expected to write 1 byte but instead wrote %d"
+			"\n",
+			bytesWritten
+		);
+	}
+	
+	bytesRead = read(cToP[0], &buffer, 1);
+	if (bytesRead == -1) {
+		printf("Error when reading byte from child\n");
+		return 1;
+	}
+	else if (bytesRead != 1) {
+		printf("Error in parent: Expected to read 1 byte but instead read %d"
+			"\n",
+			bytesRead
+		);
+		return 1;
+	}
+	
+	if(buffer == b) {
+		printf("%d: received pong\n", getpid());
+	}
+	else {
+		printf("Error in parent. Expecting %d but got %d\n", b, buffer);
+		return 1;
+	}
+	
+	return 0;
+}
+
+int main(int argc, char* argv[]) {
+	int childPid;
+	if (pipe(pToC) == -1) {
+		printf("Could not create pipe pToC\n");
+		return 1;
+	}
+	if (pipe(cToP) == -1) {
+		printf("Could not create pipe cToP\n");
+		return 1;
+	}
+	
+	childPid = fork();
+	if (childPid == -1) {
+		printf("fork failed\n");
+		return 1;
+	}
+	else if (childPid == 0) {
+		child();
+	}
+	else {
+		parent();
+	}
+	return 0;
+	
+}
\ No newline at end of file
diff --git a/assignments/xv6/user/primes.c b/assignments/xv6/user/primes.c
new file mode 100644
index 0000000..7456abd
--- /dev/null
+++ b/assignments/xv6/user/primes.c
@@ -0,0 +1,202 @@
+/*
+* @author Wahhaj Javed, muj975, 11135711
+* @author Nakhba Mubashir, epl482, 11317060
+* @date 2024-09-30
+*/
+
+#include "kernel/types.h"
+#include "user/user.h"
+
+#define MAX_INT 35
+
+int pipe1[2]; //incoming
+int pipe2[2]; //outgoing
+int incoming = -1;
+int outgoing = -1;
+
+void print_state() {
+	printf("%d: pipe 1 = {%d, %d}, pipe 2 = {%d, %d}, "
+		"incoming = %d, outgoing = %d\n", 
+		getpid(), pipe1[0], pipe1[1], pipe2[0], pipe2[1], incoming, outgoing
+	);
+}
+
+int createProcess() {
+	int childPid;
+	
+	if (pipe2[0] != -1 && pipe2[1] != -1) {
+		printf("%d: Can not create process as pipe2 is already initialized.\n", 
+			getpid()
+		);
+		return -1;
+	}
+	
+	if (pipe(pipe2) == -1) {
+		printf("%d: Could not create pipe2 pipe.\n", getpid());
+		return -1;
+	}
+	
+	childPid = fork();
+	if (childPid == -1) {
+		printf("%d: fork failed in createProcess().\n", getpid());
+		return -1;
+	}
+	else if (childPid == 0) {
+		if(close(pipe1[0]) != 0) {
+			printf("%d: Error in createProcess. Could not close pipe1[0]\n", 
+				getpid()
+			);
+			return -1;
+		}
+		if(close(pipe2[1]) != 0) {
+			printf("%d: Error in createProcess. Could not close pipe2[1]\n", 
+				getpid()
+			);
+			return -1;
+		}
+		
+		pipe1[0] = pipe2[0];
+		pipe2[0] = -1;
+		pipe2[1] = -1;
+	}
+	else {
+		if(close(pipe2[0]) != 0) {
+			printf("%d: Error in createProcess. Could not close pipe2[0]\n", 
+				getpid()
+			);
+			return -1;
+		}
+		pipe2[0] = -1;
+	}
+	
+	incoming = pipe1[0];
+	outgoing = pipe2[1];
+	return childPid;
+	
+}
+
+void prime() {
+	int childPid, divisor, number, bytesRead, bytesWritten, closedPid, status;
+	childPid = -1;
+	divisor = -1;
+	
+	while(1) {
+		bytesRead = read(incoming, &number, 4);
+		if (bytesRead == 0) {
+			break;
+		}
+		else if (bytesRead != 4) {
+			printf("%d: Error when reading number.\n", getpid());
+			break;
+		}
+		if (divisor == -1) {
+			printf("prime %d\n", number);
+			// printf("%d: prime %d\n", getpid(),number);
+			divisor = number;
+			continue;
+		}
+
+		//if remainder is 0, not a prime so drop the integer
+		if (number % divisor == 0) {
+			continue;
+		}
+
+		if (outgoing == -1) {
+			childPid = createProcess(&incoming, &outgoing);
+			if (childPid == -1) {
+				printf("%d: Could not create new process in prime().\n",
+					getpid()
+				);
+				return;
+			}
+			else if (childPid == 0) {
+				divisor = -1;
+				continue;
+			}
+		}
+		bytesWritten = write(outgoing, &number, 4);
+		if ( bytesWritten != 4) {
+			if (bytesWritten == -1)
+				printf("%d: Downstream pipe closed.\n", getpid());
+			else
+				printf("%d: Error when writing number.\n", getpid());
+			return;
+		}
+		
+	}
+	
+	if (outgoing != -1 && close(outgoing) != 0) {
+		printf("%d: Error in prime. Could not close outgoing.\n", getpid());
+		return;
+	}
+	if((closedPid = wait(&status) != childPid)) {
+			// printf("%d: Process %d closed\n", getpid(), closedPid);
+	}
+	return;
+}
+
+void parent(int outgoing) {
+	int nextInt, bytesWritten;
+	nextInt = 1;
+	while (nextInt++ <= MAX_INT) {
+		// sleep(1);
+		if ((bytesWritten = write(outgoing, &nextInt, 4)) != 4) {
+			if (bytesWritten == -1)
+				printf("%d: Downstream pipe closed.\n", getpid());
+			else {
+				printf("%d: Error when writing nextInt.\n", getpid());
+				printf("%d: Expected to write 4 bytes but instead wrote %d.\n",
+					getpid(),
+					bytesWritten
+				);
+			}
+			return;
+		}
+	}
+
+	if (close(outgoing) != 0) {
+		printf("%d: Error in main. Could not close outgoing.\n", getpid());
+		return;
+	}
+	outgoing = -1;
+}
+
+int main(int argc, char* argv[]) {
+	int childPid, status, closedPid;
+	
+	pipe1[0] = -1;
+	pipe1[1] = -1;
+	pipe2[0] = -1;
+	pipe2[1] = -1;
+	if (pipe(pipe1) == -1) {
+		printf("%d: Could not create pipe1 pipe.\n", getpid());
+		return 1;
+	}
+	if(close(pipe1[1]) != 0) {
+		printf("%d: Error in main. Could not close pipe1[1]\n", 
+			getpid()
+		);
+		return -1;
+	}
+	pipe1[1] = -1;
+
+	childPid = createProcess();
+	if (childPid == -1) {
+		printf("%d: Could not create new process. Exiting program.\n", 
+			getpid()
+		);
+		return 1;
+	}
+	else if (childPid == 0) {
+		prime();
+	}
+	else {
+		parent(outgoing);
+		while((closedPid = wait(&status) != childPid)) {
+			// printf("%d: Process %d closed\n", getpid(), closedPid);
+		}
+		// sleep(1); //so shell prompt doesn't end up as part of program output
+	}
+	// printf("Process %d exiting.\n", getpid());
+	return 0;
+}
\ No newline at end of file
diff --git a/assignments/xv6/user/trace.c b/assignments/xv6/user/trace.c
new file mode 100644
index 0000000..dd77760
--- /dev/null
+++ b/assignments/xv6/user/trace.c
@@ -0,0 +1,27 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+  char *nargv[MAXARG];
+
+  if(argc < 3 || (argv[1][0] < '0' || argv[1][0] > '9')){
+    fprintf(2, "Usage: %s mask command\n", argv[0]);
+    exit(1);
+  }
+
+  if (trace(atoi(argv[1])) < 0) {
+    fprintf(2, "%s: trace failed\n", argv[0]);
+    exit(1);
+  }
+  
+  for(i = 2; i < argc && i < MAXARG; i++){
+    nargv[i-2] = argv[i];
+  }
+  exec(nargv[0], nargv);
+  exit(0);
+}
diff --git a/assignments/xv6/user/user.h b/assignments/xv6/user/user.h
index 542f5b6..65bb0ef 100644
--- a/assignments/xv6/user/user.h
+++ b/assignments/xv6/user/user.h
@@ -22,6 +22,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int trace(int);
+
 
 /* ulib.c */
 int stat(const char*, struct stat*);
diff --git a/assignments/xv6/user/usys.pl b/assignments/xv6/user/usys.pl
index 01e426e..4c32c04 100755
--- a/assignments/xv6/user/usys.pl
+++ b/assignments/xv6/user/usys.pl
@@ -14,7 +14,7 @@ sub entry {
     print " ecall\n";
     print " ret\n";
 }
-	
+
 entry("fork");
 entry("exit");
 entry("wait");
@@ -36,3 +36,4 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");
