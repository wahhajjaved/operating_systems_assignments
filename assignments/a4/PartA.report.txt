Wahhaj Javed, muj975, 11135711
Nakhba Mubashir, epl482, 11317060

Assignmnet 4 report:

Introduction:
Memory managemnet is a critical part of a system's performance. This report
focuses on evaluation the fragmentation and efficency of the two memory
allocation algorithms; first-fit(BF) and best-fit(BF). These algorithms are
simulated and analyzed through bash and python, with algorithm implemented in
the C lannguage.

FF algorithm allocates memory to the first available segment that satisfies
the size requirement, whereas, BF algorithm searches thw whole list of
available memory segments for the smallest block to fit our request.

Experiment Design/Design decision:
The performance of a memory management algorithm can be judged by how fast it
can allocate memory, how fast it can free it, how fragmented it leaves the
memory. The memory is stored in two lists, one for used segments and one
for free segments.

Allocating memory requires searching the free list to find a suitable segment
and moving it to the used list. Therefore, the allocation performance can be
measured using the number of nodes in searched in the free list. The fewer
nodes searched, the better the performance.

First fit should perform better in this category than best fit as FF will use
the first segment that is big enough, where as BF will search the entire
free list every time.

Deallocating memory requires searching the used list to find the segment and
moving it to the free list. The segment must then be merged with adjacent
segments if possible. Searching through the used list will take the same amount
of time for both algorithms. However, merging adjacent segments in the free
list is expected to be slightly different, because of different fragmentation
levels.

The last criteria if fragmentation. There can be two types of fragmentation:
internal and external. FF and BF both allocate the request memory exactly so
internal fragmentation will be 0. However, external fragmentation will be
different for the two algorithms.

BF aims to reduce fragmentation by searching for the closest block size so
in the results, we should see BF outperform FF in the fragmentation category.
Because of reduced fragmentation, the number of nodes searched when merging
a deallocated memory segment should be fewer than FF.


Analysis:

Both FF and BF achieve the same number of allocations and deallocations across
threads and iterations. As the number of iterations increases, the total number
of allocations and deallocations grows linearly. This is expected as we
allocate once per iterations so the total number of allocations should equal
numThreads x numIterations. Deallocations happen with a 50% chance on each
iteration so totalDelocations should be approx. (numThreads x numIterations) /2,
which they are.

Across all experiments, BF searched more nodes for when allocating than FF.
This matches the predicted outcome.  The number of searched nodes when
deallocating are similar between the two algorithms. This is expected because
there is no special optimization applied the used memory list so both algorithms
search this list identically.

The unallocated median segment size gives an idea of how big the holes are.
FF on average generates larger sized holes whereas BF fills the memory
with small holes that can't be used. The median segment size becomes smaller
as the number of iterations increases for both algorithms. This makes sense.
Allocating memory requires segmenting a hole therefore as more memory is
allocated, more sements are created.

The median unallocated segment size for FF is at least 2.5 times bigger than for
BF, at 1000 allocations. As the number of allocations increases, this gap
increases with FF's median unallocated size becoming 4.1 times larger than BF
at 15000 allocations. This indicates that BF creates more fragmentation over
time due to it finding the smallest suitable block.

As the number of threads grows, both FF and BF shows an increase in the number
of nodes searched during allocation and deallocation. For example, with 100
threads and 1,000 iterations, FF searched 20,000 nodes, while BF searched
30,000 nodes. Higher iteration counts (e.g., 2,000 iterations) lead to
increased fragmentation in both algorithms, but the fragmentation patterns
differ. FF tends to produce fewer larger fragments, while BF creates more
smaller fragments.



Conclusion:
FF performs better with about the same number of unallocated segments,
but larger unallocated segments over time. BF requires more computation during
allocation due to its exhaustive search. During allocation, BF results in more
fragmentation, but these fragments tend to be smaller. If speed and simplicity
are the priorities, FF is the better choice, as it searched 50% fewer node in
many tests. However, if the goal is to minimize fragmentation, BF might be
preferable despite its higher computational overhead.







The number of unallocated segments is high across the board for FF than BF.
This is also the expected outcome as BF is an algorithm that trades speed
for reduced fragmentation. BF vastly outperforms FF when it comes to
fragmentation. This can be seen when looking at the median of the unallocated
segment sizes and the largest unallocated segment.

The unallocated median segment size gives an idea of how big the holes are.
The memory starts as one large hole and ideally we want to maintain that
situation. If the median is small, that means most holes are small in size
and the rest of the memory is in the one big hole.

