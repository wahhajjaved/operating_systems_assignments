# @author Wahhaj Javed, muj975, 11135711
# @author Nakhba Mubashir, epl482, 11317060

----------------------------
XV6 part A design

Threading:

uthread_switch.S:
thread_switch: 
    it accepts 2 parameters, a pointer to a current thread,and a pointer to 
    the thread to switch to.
    this function performs context switch by storing the thread switching in 
    a struct and loading new. i checked the two .S files from kernel directory
    i copied the code from swtch.S from kernel directory to thread_switch.
    the purpose of swtch.S is the same as thread_switch().

uthread.h:

    file created to add thread switch to uthread.c
usertests.c:
    added the testing code in this file from uthread.c to preent compiling
    error


uthread.c:
thread_create(void (*tmain)()):
    added the checking for available thread for running state.
    ra is intialized to the start of func and sp is initilazised to the 
    address of the last item in the stack.so, when the thread_switch() is
    called then it will return to the start of func and the stack pointer(sp)
    is at the top of thread stack.

    in the code i used the coding design as already inside the code, 
    like "printf("thread_schedule: no runnable threads\n"); exit(-1);"

thread struct:
    used unit 64 because to ensure that it matches the register size of
    architecture.
    modified the thread struct to save/restore the registers, 
    added s0-s9, ra and sp.

thread_schedule:
    switched between threads by calling thread_switch() from uthread_switch.S
    switches from current to next thread to run.

new functions in uthread: 
"current_thread->state = FREE" is giving error so i am creating new func 
for free

thread_free():
    current_thread->state = FREE;
    thread_schedule();

**********

Mutex:

mtx.c:
struct mutex{lock}
lock flag for checking, 1 for lock and 0 for unlock
mutex mutexes[Num];

int mtx_create(int locked):
    initialize the mutexes with lock, the index is MutexNum
    and return MutexNum;

int mtx_lock(int lock_id):
    if the lock id is valid:
        then spin untill lock
        set mutext.lock to 1

int mtx_unlocked(int lock_id):
    set mutex.lock to unlock

prod-con-mtx:

int buffMax   // max buffer size
int buffSize  // size of buffer, how many items are in buffer
int mutex

prod:
    for (;;;) //used for loop because prof said its cheaper than while(1)
    lock mutex
    if buffer not full
        incriment through the buffer, unlock the buffer
    else: unlock and consumew the thread through thread_yeild()

con:
    for (;;;) //used for loop because prof said its cheaper than while(1)
    lock mutex
    if buffer more than 0 // we dont care if buffer is full or not
                          // it should just have any items to consume
        decreament through the buffer, unlock the buffer
    else: unlock and consumew the thread through thread_yeild()

main:
    initialize all the variables
    create/ initialize the mutex
    create 1 producer and 1 consumer threa
    used the main from uthread to construct this main

    the buffersize and buffermax can be comand line arguments, if want 
    diffrenent size every time.

**********

counting semaphore using mutex:

sem:
used mtx.c to construct sem

typedef struct _semaphore{
    int value; /*holds the semaphore value */
}Semaphore;

#define NUM_SEM 5 

int sem_create(int val):
     initialize mutex
    lock the mutex to make sure only one thread at a time
    set each semaphore to val
    unlock
    return the index

int P(int semVal):
    lock the mutex to make sure only one thread at a time
    reduce the semaphore value
    unlock
    return 0 if sucessfull

int v(int semVal)
    lock the mutex to make sure only one thread at a time
    increase the semaphore value
    unlock
    return 0 if sucessfull

prod-con-sem.c
used prod-con-mtx as an outline, changed it so it works with semaphore
int mtx, full, empty  //3 semaphoes
                      // empty tracks the available spaces so set to max value
                      // full tracks the filled slots so set to 0
//making empty and full seperately will prevent deadlock and it will allow 
//the prouducer and consumer to work independently 

prod:
    for all the items in buffer
        P(empty);
        P(mtx); /* locks the critical section*/
        increase the buffer
        V(mtx);
        V(full);
        sleep(10); /*to slow it down*/
        thread yeild so other threads can run

con:
    for all the items in buffer
        P(full);
        P(mtx); /* locks the critical section*/
        increase the buffer
        V(mtx);
        V(empty);
         thread yeild so other threads can run


main:
    initialize all the variable
    check the variables and border cases
    create consumer and producer thread


it was changing veryfast so added sleep(10) to prod

problem with solution:
everytime buffer is used up, new producer and consumer are created, i dont
think new producer and consumer are supposed to be created each time. there
is a for loop with buffermaxsize as value, thats why its created each time.
if i sont put the buffermaxsize then it only run for 1 and 0.

---

Makefile:
added the target rules for uthread,mtx and sem

