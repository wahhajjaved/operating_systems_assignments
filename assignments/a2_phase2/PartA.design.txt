# @author Wahhaj Javed, muj975, 11135711
# @author Nakhba Mubashir, epl482, 11317060

----------------------------
XV6 part A design

Threading:

uthread_switch.S:
thread_switch: 
    it accepts 2 parameters, a pointer to a current thread,and a pointer to 
    the thread to switch to.
    this function performs context switch by storing the thread switching in 
    a struct and loading new. i checked the two .S files from kernel directory
    i copied the code from swtch.S from kernel directory to thread_switch.
    the purpose of swtch.S is the same as thread_switch().

uthread.h:

    file created to add thread switch to uthread.c
usertests.c:
    added the testing code in this file from uthread.c to preent compiling
    error


uthread.c:
thread_create(void (*tmain)()):
    added the checking for available thread for running state.
    ra is intialized to the start of func and sp is initilazised to the 
    address of the last item in the stack.so, when the thread_switch() is
    called then it will return to the start of func and the stack pointer(sp)
    is at the top of thread stack.

    in the code i used the coding design as already inside the code, 
    like "printf("thread_schedule: no runnable threads\n"); exit(-1);"

thread struct:
    used unit 64 because to ensure that it matches the register size of
    architecture.
    modified the thread struct to save/restore the registers, 
    added s0-s9, ra and sp.

thread_schedule:
    switched between threads by calling thread_switch() from uthread_switch.S
    switches from current to next thread to run.

new functions in uthread: 
"current_thread->state = FREE" is giving error so i am creating new func 
for free

thread_free():
    current_thread->state = FREE;
    thread_schedule();

**********

Mutex:

mtx.c:
struct mutex{lock}
lock flag for checking, 1 for lock and 0 for unlock
mutex mutexes[Num];

int mtx_create(int locked):
    initialize the mutexes with lock, the index is MutexNum
    and return MutexNum;

int mtx_lock(int lock_id):
    if the lock id is valid:
        then spin untill lock
        set mutext.lock to 1

int mtx_unlocked(int lock_id):
    set mutex.lock to unlock

prod-con-mtx:

int buffMax   // max buffer size
int buffSize  // size of buffer, how many items are in buffer
int mutex

prod:
    for (;;;) //used for loop because prof said its cheaper than while(1)
    lock mutex
    if buffer not full
        incriment through the buffer, unlock the buffer
    else: unlock and consumew the thread through thread_yeild()

con:
    for (;;;) //used for loop because prof said its cheaper than while(1)
    lock mutex
    if buffer more than 0 // we dont care if buffer is full or not
                          // it should just have any items to consume
        decreament through the buffer, unlock the buffer
    else: unlock and consumew the thread through thread_yeild()

main:
    initialize all the variables
    create/ initialize the mutex
    create 1 producer and 1 consumer threa
    used the main from uthread to construct this main

    the buffersize and buffermax can be comand line arguments, if want 
    diffrenent size every time.

**********

counting semaphore using mutex:

sem:
used mtx.c to construct sem

prod-con-sem.c
used prod-con-mtx as an outline, changed it so it works with semaphore
int mtx, full, empty  //3 semaphoes
                      // empty tracks the available spaces
                      // full tracks the filled slots
//making empty and full seperately will prevent deadlock and it will allow 
//the prouducer and consumer to work independently 

prod:

    
---

Makefile:
added the target rules for uthread,mtx and sem

