diff --git a/assignments/a2_phase2/xv6-riscv/Makefile b/assignments/a2_phase2/xv6-riscv/Makefile
new file mode 100644
index 0000000..52062a2
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/Makefile
@@ -0,0 +1,208 @@
+	$U/_trace\
+	$U/_uthread\
+	$U/_prod-con-mtx\
+	$U/_prod-con-sem\
+ 
+#CMPT 332 GROUP 67 Change, Fall 2024 
+
+UTHREAD=$U/uthread.o $U/uthread_switch.o $U/mtx.o
+
+$U/uthread_switch.o: $U/uthread_switch.S
+	$(CC) $(CFLAGS) -c -o $U/uthread_switch.o $U/uthread_switch.S
+
+$U/_uthread: $U/uthreadtest.o  $U/uthread.o $U/uthread_switch.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_uthread $U/uthread.o \
+		$U/uthread_switch.o $U/uthreadtest.o $(ULIB)
+	$(OBJDUMP) -S $U/_uthread > $U/uthread.asm
+
+$U/_prod-con-mtx: $U/prod-con-mtx.o $(UTHREAD)  $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_prod-con-mtx \
+        $U/prod-con-mtx.o  $(UTHREAD) $(ULIB)
+
+$U/_prod-con-sem: $U/prod-con-sem.o $U/sem.o $(UTHREAD)  $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_prod-con-sem \
+        $U/prod-con-sem.o $U/sem.o $(UTHREAD) $(ULIB)
+
+

diff --git a/assignments/a2_phase2/xv6-riscv/user/mtx.c b/assignments/a2_phase2/xv6-riscv/user/mtx.c
new file mode 100644
index 0000000..5d134fa
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/mtx.c
@@ -0,0 +1,45 @@
+/*
+ *@author Wahhaj Javed, muj975, 11135711
+ *@author Nakhba Mubashir, epl482, 11317060
+ */
+
+#include "user/mtx.h"
+#include "user/uthread.h"
+
+typedef struct mutex{
+    int lock;
+}Mutex;
+/*
+ *lock= 1 when mutex locked
+ * */
+#define NUM_MUTEX 5
+
+Mutex mutexes[NUM_MUTEX];
+
+int mtx_create(int locked){
+    int mutexNum=0;
+    mutexes[mutexNum].lock = locked;
+    return mutexNum;
+}
+int mtx_lock(int lock_id){
+    if (lock_id >0){
+        return -1; /*invalid output */
+    }
+    /* wait untill lock is aquired, blocking others  */
+    while (mutexes[lock_id].lock){
+        thread_yield(); 
+    }
+    /* lock */
+    mutexes[lock_id].lock =1;
+    return 0;
+
+}
+int mtx_unlocked(int lock_id){
+    if (lock_id >0){
+        return -1; /*invalid output */
+    }
+    /*release lock */
+    mutexes[lock_id].lock =0;
+    return 0;
+}
+
diff --git a/assignments/a2_phase2/xv6-riscv/user/mtx.h b/assignments/a2_phase2/xv6-riscv/user/mtx.h
new file mode 100644
index 0000000..791397a
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/mtx.h
@@ -0,0 +1,14 @@
+/*
+ *@author Wahhaj Javed, muj975, 11135711
+ *@author Nakhba Mubashir, epl482, 11317060
+ */
+
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/param.h"
+
+
+int mtx_create(int locked);
+int mtx_lock(int lock_id);
+int mtx_unlocked(int lock_id);
+
diff --git a/assignments/a2_phase2/xv6-riscv/user/prod-con-mtx.c b/assignments/a2_phase2/xv6-riscv/user/prod-con-mtx.c
new file mode 100644
index 0000000..2c82bff
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/prod-con-mtx.c
@@ -0,0 +1,79 @@
+
+/*
+ *@author Wahhaj Javed, muj975, 11135711
+ *@author Nakhba Mubashir, epl482, 11317060
+ */
+
+#include "user/mtx.h"
+#include "user/uthread.h"
+
+#define buffSizeVal 5
+#define buffMaxVal 6
+static int mtx, buffMax, buffSize;
+
+void prod(void){
+    printf("Producer created\n");
+    thread_yield();
+    /*run till all are produced*/
+    for (;;){
+        mtx_lock(mtx);
+        if (buffSize < buffMax){
+                thread_yield();
+                buffSize++;
+                printf("Producer: added to the buffer: %d / %d \n",buffSize,
+            buffMax );
+                mtx_unlocked(mtx);
+        }else{
+        mtx_unlocked(mtx);
+        thread_yield();
+        }
+    }
+}
+
+void con(void){
+    printf("Consumer created\n");
+    thread_yield();
+    /*run till all are consumed*/
+    for (;;){
+        mtx_lock(mtx);
+        if (buffSize > 1){
+                thread_yield();
+                buffSize--;
+                printf("Producer: removed from the buffer: %d / %d \n",
+                    buffSize, buffMax );
+                mtx_unlocked(mtx);
+        }else{
+        mtx_unlocked(mtx);
+        thread_yield();
+        }
+    }
+}
+
+int main(int argc, char *argv[]){
+    /*initialize the mutex */
+    mtx= mtx_create(0);
+    buffSize=buffSizeVal;
+    buffMax=buffMaxVal;
+
+    /*checking for invalid */
+    if (buffMax < 1){
+        printf("prod-con-mtx: bufferMax cant not be less than 1\n");
+        exit(1);
+    }
+    if (buffSize <0 || buffSize >buffMax){
+        printf("prod-con-mtx: bufferSize cant not be less than 0\n" 
+                " or more than buffermax\n");
+        exit(1);
+    }
+
+    /* create producer and consumer threads*/
+    thread_init(); 
+    thread_create(prod);
+    thread_create(con);
+    thread_schedule();
+
+    exit(0);
+    
+
+}
+
diff --git a/assignments/a2_phase2/xv6-riscv/user/prod-con-sem.c b/assignments/a2_phase2/xv6-riscv/user/prod-con-sem.c
new file mode 100644
index 0000000..2e38b89
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/prod-con-sem.c
@@ -0,0 +1,78 @@
+/*
+ *@author Wahhaj Javed, muj975, 11135711
+ *@author Nakhba Mubashir, epl482, 11317060
+ */
+
+#include "user/sem.h"
+
+#define buffSizeVal 6
+#define buffMaxVal 6
+
+static int mtx, buffMax, buffSize, empty, full;
+
+void prod(void){
+    int i;
+    printf("Producer created\n");
+    thread_yield();
+    /*run till all are produced*/
+    for (i=0;i<buffMax;i++){
+        P(empty);
+        P(mtx); /* locks the critical section*/
+            thread_yield();
+        buffSize++;
+        printf("Producer: added to the buffer: %d / %d \n",i+1,
+            buffMax );
+        V(mtx);
+        V(full);
+        sleep(10); /*to slow it down*/
+        thread_yield();
+    }
+}
+
+
+void con(void){
+    int i;
+    printf("Consumer created\n");
+    thread_yield();
+    /*run till all are produced: buffer size*/
+    for (i=0;i<buffMax;i++){
+        P(full);
+        P(mtx); /* locks the critical section*/
+        thread_yield();
+        buffSize--;
+        printf("Consumer:removed from the buffer:%d / %d \n",i+1,
+            buffMax );
+        V(mtx);
+        V(empty);
+        thread_yield();
+    }
+}
+int main(int argc, char *argv[]){
+    /*initialize*/
+    buffSize = 0;
+    buffMax = buffMaxVal;
+    mtx = sem_create(1);
+    full = sem_create(0);
+    empty = sem_create(buffMaxVal);
+    mtx= sem_create(1);
+    /*checking for invalid */
+    if (buffMax < 1){
+        printf("prod-con-mtx: bufferMax cant not be less than 1\n");
+        exit(1);
+    }
+    if (buffSize <0 || buffSize >buffMax){
+        printf("prod-con-mtx: bufferSize cant not be less than 0\n" 
+                " or more than buffermax\n");
+        exit(1);
+    }
+
+    /* create producer and consumer threads*/
+    thread_init(); 
+    thread_create(prod);
+    thread_create(con);
+    thread_schedule();
+    exit(0);
+}
+
+
+
diff --git a/assignments/a2_phase2/xv6-riscv/user/sem.c b/assignments/a2_phase2/xv6-riscv/user/sem.c
new file mode 100644
index 0000000..d60ab3d
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/sem.c
@@ -0,0 +1,41 @@
+/*
+ *@author Wahhaj Javed, muj975, 11135711
+ *@author Nakhba Mubashir, epl482, 11317060
+*/
+#include "user/sem.h"
+
+typedef struct _semaphore{
+    int value;
+}Semaphore;
+
+#define NUM_SEM 5
+
+Semaphore sem[NUM_SEM];
+static int mtx=-1;
+
+int sem_create(int val){
+    int i;
+    mtx_lock(mtx);
+    for (i=0; i<NUM_SEM; i++){
+            sem[i].value= val;
+            mtx_unlocked(mtx);
+            return i;
+     }
+    mtx_unlocked(mtx);
+    return -1;
+}
+
+int P(int semVal){
+    mtx_lock(mtx);
+    sem[semVal].value--;
+    mtx_unlocked(mtx);
+    return 0;
+
+}
+int V(int semVal){
+    mtx_lock(mtx);
+    sem[semVal].value++;
+    mtx_unlocked(mtx);
+    return 0;
+}
+
diff --git a/assignments/a2_phase2/xv6-riscv/user/sem.h b/assignments/a2_phase2/xv6-riscv/user/sem.h
new file mode 100644
index 0000000..673a0c1
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/sem.h
@@ -0,0 +1,15 @@
+/*
+ *@author Wahhaj Javed, muj975, 11135711
+ *@author Nakhba Mubashir, epl482, 11317060
+*/
+/*
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/param.h"
+*/
+#include "user/uthread.h"
+#include "user/mtx.h"
+
+int sem_create(int val);
+int P(int semVal);
+int V(int semVal);
diff --git a/assignments/a2_phase2/xv6-riscv/user/uthread.c b/assignments/a2_phase2/xv6-riscv/user/uthread.c
new file mode 100644
index 0000000..cd6f312
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/uthread.c
@@ -0,0 +1,183 @@
+#include "user/uthread.h"
+#include <stddef.h>
+/* Possible states of a thread: */
+/*
+#define FREE        0x0
+#define RUNNING     0x1
+#define RUNNABLE    0x2
+
+#define STACK_SIZE  8192
+#define MAX_THREAD  4
+*/
+struct thread all_thread[MAX_THREAD];
+struct thread *current_thread;
+/*extern void thread_switch(uint64, uint64);*/
+              
+void 
+thread_init(void)
+{
+  // main() is thread 0, which will make the first invocation to
+  // thread_schedule().  it needs a stack so that the first thread_switch() can
+  // save thread 0's state.  thread_schedule() won't run the main thread ever
+  // again, because its state is set to RUNNING, and thread_schedule() selects
+  // a RUNNABLE thread.
+  current_thread = &all_thread[0];
+  current_thread->state = RUNNING;
+}
+
+void 
+thread_schedule(void)
+{
+  struct thread *t, *next_thread;
+
+  /* Find another runnable thread. */
+  next_thread = 0;
+  t = current_thread + 1;
+  for(int i = 0; i < MAX_THREAD; i++){
+    if(t >= all_thread + MAX_THREAD)
+      t = all_thread;
+    if(t->state == RUNNABLE) {
+      next_thread = t;
+      break;
+    }
+    t = t + 1;
+  }
+
+  if (next_thread == 0) {
+    printf("thread_schedule: no runnable threads\n");
+    exit(-1);
+  }
+
+  if (current_thread != next_thread) {         /* switch threads?  */
+    next_thread->state = RUNNING;
+    t = current_thread;
+    current_thread = next_thread;
+    /* 
+     * Invoke thread_switch to switch from t to next_thread:
+     */
+
+    /* CMPT 332 GROUP 67 Change, Fall 2024 */
+    thread_switch(t, next_thread); 
+
+  } else
+    next_thread = 0;
+}
+
+void 
+thread_create(void (*func)())
+{
+  struct thread *t;
+
+  for (t = all_thread; t < all_thread + MAX_THREAD; t++) {
+    if (t->state == FREE) break;
+  }
+  /*t->state = RUNNABLE;*/
+  
+    /* CMPT 332 GROUP 67 Change, Fall 2024 */
+    /* check if there are any avialable threads */ 
+    if (t == all_thread+ MAX_THREAD) {
+        printf("thread_create: no threads available\n");
+        exit(-1);
+  }
+    t->state = RUNNABLE;
+
+    /* initialize ra and sp*/
+    t->ra = (uint64) (func);
+    t->sp = (uint64) (&t->stack[STACK_SIZE-1]);
+}
+
+void 
+thread_yield(void)
+{
+  current_thread->state = RUNNABLE;
+  thread_schedule();
+}
+
+void
+thread_free(void)
+{
+  current_thread->state = FREE;
+  thread_schedule();
+
+}
+
+
+
+/*
+volatile int a_started, b_started, c_started;
+volatile int a_n, b_n, c_n;
+
+void 
+thread_a(void)
+{
+  int i;
+  printf("thread_a started\n");
+  a_started = 1;
+  while(b_started == 0 || c_started == 0)
+    thread_yield();
+  
+  for (i = 0; i < 100; i++) {
+    printf("thread_a %d\n", i);
+    a_n += 1;
+    thread_yield();
+  }
+  printf("thread_a: exit after %d\n", a_n);
+
+  current_thread->state = FREE;
+  thread_schedule();
+}
+
+void 
+thread_b(void)
+{
+  int i;
+  printf("thread_b started\n");
+  b_started = 1;
+  while(a_started == 0 || c_started == 0)
+    thread_yield();
+  
+  for (i = 0; i < 100; i++) {
+    printf("thread_b %d\n", i);
+    b_n += 1;
+    thread_yield();
+  }
+  printf("thread_b: exit after %d\n", b_n);
+
+  current_thread->state = FREE;
+  thread_schedule();
+}
+
+void 
+thread_c(void)
+{
+  int i;
+  printf("thread_c started\n");
+  c_started = 1;
+  while(a_started == 0 || b_started == 0)
+    thread_yield();
+  
+  for (i = 0; i < 100; i++) {
+    printf("thread_c %d\n", i);
+    c_n += 1;
+    thread_yield();
+  }
+  printf("thread_c: exit after %d\n", c_n);
+
+  current_thread->state = FREE;
+  thread_schedule();
+}
+
+int 
+main(int argc, char *argv[]) 
+{
+  a_started = b_started = c_started = 0;
+  a_n = b_n = c_n = 0;
+  thread_init();
+  thread_create(thread_a);
+  thread_create(thread_b);
+  thread_create(thread_c);
+  thread_schedule();
+  exit(0);
+}
+
+*/
diff --git a/assignments/a2_phase2/xv6-riscv/user/uthread.h b/assignments/a2_phase2/xv6-riscv/user/uthread.h
new file mode 100644
index 0000000..c3e67f7
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/uthread.h
@@ -0,0 +1,60 @@
+/*
+ *@author Wahhaj Javed, muj975, 11135711
+ *@author Nakhba Mubashir, epl482, 11317060
+ */
+
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+/* from uthread.c*/
+/* Possible states of a thread: */
+#define FREE        0x0
+#define RUNNING     0x1
+#define RUNNABLE    0x2
+
+/*#define STACK_SIZE  8192*/
+#define STACK_SIZE  8180
+#define MAX_THREAD  4
+
+
+struct thread {
+
+    /* CMPT 332 GROUP 67 Change, Fall 2024 */
+    uint64 ra;
+    uint64 sp;
+
+    /* save/restore the registers */
+    uint64 s0;
+    uint64 s1;
+    uint64 s2;
+    uint64 s3;
+    uint64 s4;
+
+    uint64 s5;
+    uint64 s6;
+    uint64 s7;
+    uint64 s8;
+    uint64 s9;
+    uint64 s10;
+    uint64 s11;
+
+  char       stack[STACK_SIZE]; /* the thread's stack */
+  int        state;             /* FREE, RUNNING, RUNNABLE */
+};
+
+/*uthread_switch.S*/
+void thread_switch(struct thread*, struct thread*);
+
+/* uthread.c*/
+void thread_init(void);
+void thread_schedule(void);
+void thread_create(void (*func)());
+void thread_yield(void);
+void thread_free(void);
+/*
+void thread_a(void);
+void thread_b(void);
+void thread_c(void);
+*/
+
diff --git a/assignments/a2_phase2/xv6-riscv/user/uthreadtest.c b/assignments/a2_phase2/xv6-riscv/user/uthreadtest.c
new file mode 100644
index 0000000..32c40e9
--- /dev/null
+++ b/assignments/a2_phase2/xv6-riscv/user/uthreadtest.c
@@ -0,0 +1,84 @@
+#include "user/uthread.h"
+
+volatile int a_started, b_started, c_started;
+volatile int a_n, b_n, c_n;
+
+void 
+thread_a(void)
+{
+  int i;
+  printf("thread_a started\n");
+  a_started = 1;
+  while(b_started == 0 || c_started == 0)
+    thread_yield();
+  
+  for (i = 0; i < 100; i++) {
+    printf("thread_a %d\n", i);
+    a_n += 1;
+    thread_yield();
+  }
+  printf("thread_a: exit after %d\n", a_n);
+
+    /* CMPT 332 GROUP 67 Change, Fall 2024 */
+  thread_free();
+  /*current_thread->state = FREE;
+  thread_schedule();*/
+}
+
+
+void 
+thread_b(void)
+{
+  int i;
+  printf("thread_b started\n");
+  b_started = 1;
+  while(a_started == 0 || c_started == 0)
+    thread_yield();
+  
+  for (i = 0; i < 100; i++) {
+    printf("thread_b %d\n", i);
+    b_n += 1;
+    thread_yield();
+  }
+  printf("thread_b: exit after %d\n", b_n);
+    /* CMPT 332 GROUP 67 Change, Fall 2024 */
+  thread_free();
+  /*current_thread->state = FREE;
+  thread_schedule();*/
+}
+
+void 
+thread_c(void)
+{
+  int i;
+  printf("thread_c started\n");
+  c_started = 1;
+  while(a_started == 0 || b_started == 0)
+    thread_yield();
+  
+  for (i = 0; i < 100; i++) {
+    printf("thread_c %d\n", i);
+    c_n += 1;
+    thread_yield();
+  }
+  printf("thread_c: exit after %d\n", c_n);
+
+    /* CMPT 332 GROUP 67 Change, Fall 2024 */
+  thread_free();
+  /*current_thread->state = FREE;*/
+  /*thread_schedule();*/
+}
+
+int 
+main(int argc, char *argv[]) 
+{
+  a_started = b_started = c_started = 0;
+  a_n = b_n = c_n = 0;
+  thread_init();
+  thread_create(thread_a);
+  thread_create(thread_b);
+  thread_create(thread_c);
+  thread_schedule();
+  exit(0);
+}
+
